## 汇编语言学习

暂时没有啥条理，等之后有时间一定整理一下（也可能忘记了或者单纯的懒完全没整理）

#### 通用寄存器

AX可存16位 但AL或者AH只能存8位

例如：AX的数据为001A 则AH中保存的数据为**00** 而AL中保存的数据为**1A** 

也就是说，001A在地址的视角中应该是**1A 00**

#### 不通用寄存器

##### DS

一般用DS寄存器来存放要访问的数据的段的地址

若想改变DS寄存器中的内容，只能通过将数据传入其他通用寄存器之后，再使用mov命令将该通用寄存器中的内容传入DS中

##### CS:IP

从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器;
P=IP+所读取指令的长度，从而指向下一条指令;
执行指令。转到步骤(1)，重复这个过程。

**CS:IP先变化再执行指令**

#### 段的概念

A:B的真实地址是A*16+B

2000:B这个地址的真实值是2000B

#### 栈的概念

栈寄存器为SS:SP

![image-20240812152714688](C:\Users\CherryColaOvO\AppData\Roaming\Typora\typora-user-images\image-20240812152714688.png)

入栈时，栈顶从高地址向低地址的方向增长

栈空时，栈顶指针指向最高地址的的下一个单元（最高地址+1）

![image-20240812152918914](C:\Users\CherryColaOvO\AppData\Roaming\Typora\typora-user-images\image-20240812152918914.png)

出栈是，是先将数据输送至指定寄存器，再变化指针。原数据不会被删除，而是等待被覆盖

### 第五章

#### Loop指令

 CPU执行loop指令时，要进行两步操作。

1.(cx) = (cx)-1

2.判断cx中的值

举例：

```
assume cs :code
code segment
	mov ax,2
	;做 11 次 add ax,ax
	;下面两行就当是return 0
	mov ax,4c00h
	int 21h
code ends
end
```

11次太长了，用loop简化一下

```
assume cs :code
code segment
	mov ax,2
	
	mov cx,11
s:	add ax,ax
	loop s
	;做 11 次 add ax,ax
	;下面两行就当是return 0
	mov ax,4c00h
	int 21h
code ends
end
```

由上可知，loop的用法是先定义循环次数，将循环次数存入cx。

再定义循环语句 s

最后使用loop s来实施循环

#### Debug和编译器masm对指令的不同处理

形如 mov al,[0] 的这类指令在Debug中编程正常实现，但是在汇编程序中便出现了问题。 Debug会将[0]解释成内存单元，其中的0为内存的偏移地址；而编译器将[0]直接解释为0。

因此，如果我们需要在汇编程序中实现mov al,[0] 的指令，需要将其转变为 

mov al,ds:[0]便可以正常运行 





